/// The request-reply interface allows a guest to send a message and await a response. This
/// interface is considered optional as not all message services support the concept of
/// request/reply. However, request/reply is a very common pattern in messaging and as such, we have
/// included it as a core interface.
interface request-reply {
    use types.{client, message, error};

    /// Options for a request/reply operation
    record request-options {
        /// The maximum amount of time to wait for a response. If the timeout value is not set, then
        /// the request/reply operation will block until a message is received in response.
        timeout-ms: option<u32>,
        /// The number of expected replies. If the number of replies is not set, then the
        /// request/reply operation will block until a single message is received in response (or a
        /// timeout value is reached). This can be used in conjunction for "scatter/gather" type
        /// operations.
        expected-replies: option<u32>,
    }

    /// Performs a blocking request/reply operation with an optional set of request options
    request: func(c: client, msg: message, opts: option<request-options>) -> result<option<list<message>>, error>;

    /// Replies to the given message with the given response message. The details of which channel 
    /// the message is sent to is up to the implementation. This allows for reply to details to be
    /// handled in the best way possible for the underlying messaging system.
    reply: func(reply-to: borrow<message>, reply: message) -> result<_, error>;
}